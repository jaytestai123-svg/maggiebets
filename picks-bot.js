// MaggieBets Daily Picks Bot
// Checks multiple sports, generates picks or research based on availability

const SPORTS_CONFIG = {
  nba: {
    name: 'NBA Basketball',
    apiUrl: 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard',
    seasonCheck: (data) => {
      const day = data.day?.date;
      // NBA season typically Oct-June
      const month = day ? parseInt(day.split('-')[1]) : 0;
      return month >= 10 || month <= 6;
    }
  },
  nhl: {
    name: 'NHL Hockey',
    apiUrl: 'https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard',
    seasonCheck: (data) => {
      const day = data.day?.date;
      const month = day ? parseInt(day.split('-')[1]) : 0;
      return month >= 10 || month <= 6;
    }
  },
  mlb: {
    name: 'MLB Baseball',
    apiUrl: 'https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard',
    seasonCheck: (data) => {
      const day = data.day?.date;
      const month = day ? parseInt(day.split('-')[1]) : 0;
      return month >= 2 && month <= 10;
    }
  },
  mls: {
    name: 'MLS Soccer',
    apiUrl: 'https://site.api.espn.com/apis/site/v2/sports/soccer/usa.1/scoreboard',
    seasonCheck: (data) => {
      // MLS typically March-Oct
      const day = data.day?.date;
      const month = day ? parseInt(day.split('-')[1]) : 0;
      return month >= 3 && month <= 10;
    }
  },
  ncaab: {
    name: 'NCAA Basketball',
    apiUrl: 'https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/scoreboard',
    seasonCheck: (data) => {
      const day = data.day?.date;
      const month = day ? parseInt(day.split('-')[1]) : 0;
      // NCAA season Nov-March
      return month >= 11 || month <= 3;
    }
  }
};

function getDateString(daysAhead = 0) {
  const d = new Date();
  d.setDate(d.getDate() + daysAhead);
  return d.toISOString().split('T')[0].replace(/-/g, '');
}

function extractGames(data) {
  const events = data.events || [];
  const now = new Date();
  const games = [];
  
  for (const event of events) {
    const gameTime = new Date(event.date);
    const hoursUntilGame = (gameTime - now) / (1000 * 60 * 60);
    
    // Only include games in next 48 hours
    if (hoursUntilGame > 0 && hoursUntilGame <= 48) {
      const competitors = event.competitions?.[0]?.competitors || [];
      const home = competitors.find(c => c.homeAway === 'home');
      const away = competitors.find(c => c.homeAway === 'away');
      
      if (home && away) {
        games.push({
          id: event.id,
          time: event.date,
          home: home.team,
          away: away.team,
          venue: event.competitions?.[0]?.venue?.fullName
        });
      }
    }
  }
  
  return games;
}

function generatePick(game, sport) {
  // Simple pick logic - in production, this would be more sophisticated
  const homeName = game.home?.abbreviation;
  const awayName = game.away?.abbreviation;
  
  // For now, generate a reasoned pick based on basic analysis
  return {
    pick: `${homeName} vs ${awayName}`,
    recommendation: 'Analysis pending - check back closer to game time',
    confidence: 'Medium',
    factors: ['Recent form', 'Injuries', 'Home/away splits']
  };
}

function generateResearchReport(sport, upcomingGames) {
  const sportName = SPORTS_CONFIG[sport]?.name || sport;
  
  let report = `# ${sportName} Research Report\n\n`;
  report += `**Date:** ${new Date().toLocaleDateString()}\n\n`;
  report += `## Upcoming Games\n\n`;
  
  if (upcomingGames.length === 0) {
    report += `No games in the next 48 hours.\n\n`;
  } else {
    for (const game of upcomingGames.slice(0, 5)) {
      const gameTime = new Date(game.time);
      report += `â€¢ **${game.away?.displayName} @ ${game.home?.displayName}**\n`;
      report += `  ðŸ“… ${gameTime.toLocaleDateString()} @ ${gameTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}\n`;
      report += `  ðŸ“ ${game.venue || 'TBD'}\n\n`;
    }
  }
  
  report += `---\n*Generated by MaggieBets AI*`;
  
  return report;
}

async function checkSport(sportKey) {
  const config = SPORTS_CONFIG[sportKey];
  if (!config) return null;
  
  try {
    const response = await fetch(config.apiUrl);
    const data = await response.json();
    
    // Check if in season
    const inSeason = config.seasonCheck(data);
    
    // Get games in next 48 hours
    const games = extractGames(data);
    
    return {
      sport: sportKey,
      name: config.name,
      inSeason,
      gamesToday: games.length,
      games: games,
      nextGameDate: games[0]?.time || null
    };
  } catch (error) {
    console.error(`Error checking ${sportKey}:`, error.message);
    return {
      sport: sportKey,
      name: config.name,
      error: error.message
    };
  }
}

async function runDailyPicks() {
  const results = {
    timestamp: new Date().toISOString(),
    sports: {}
  };
  
  // Check all sports
  const sportKeys = Object.keys(SPORTS_CONFIG);
  const checks = await Promise.all(sportKeys.map(checkSport));
  
  for (const check of checks) {
    if (check) {
      results.sports[check.sport] = check;
    }
  }
  
  // Determine what to output
  const sportsWithGames = checks.filter(c => c?.gamesToday > 0);
  const inSeasonSports = checks.filter(c => c?.inSeason);
  
  let output = {
    hasPicks: sportsWithGames.length > 0,
    sportsChecked: sportKeys.length,
    sportsWithGames: sportsWithGames.map(s => s.name),
    inSeason: inSeasonSports.map(s => s.name),
    picks: [],
    research: []
  };
  
  // Generate picks for games today
  if (sportsWithGames.length > 0) {
    for (const sport of sportsWithGames) {
      for (const game of sport.games) {
        output.picks.push(generatePick(game, sport.sport));
      }
    }
  }
  
  // Generate research for upcoming sports
  for (const sport of inSeasonSports) {
    if (sport.gamesToday === 0 && sport.nextGameDate) {
      output.research.push(generateResearchReport(sport.sport, sport.games));
    }
  }
  
  results.output = output;
  
  return results;
}

module.exports = { runDailyPicks, SPORTS_CONFIG };
